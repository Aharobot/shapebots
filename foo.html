<!DOCTYPE html>
<html>
<head>
</head>
<body>
  Robots
  <pre id="robots"></pre>
  Markers
  <pre id="markers"></pre>
  Angles
  <pre id="angles"></pre>
  <pre id="constraints"></pre>
  <pre id="pointer"></pre>
  <canvas id="canvas" width="1000" height="500"></canvas>
  <canvas id="panel" width="200" height="500"></canvas>

  <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io.connect('http://localhost:4000/')

    socket.on('rect:update', function (rect) {
      window.rect = rect
    })

    socket.on('robots:update', function (robots) {
      window.robots = robots
      robots = robots.map((robot) => {
        return { x: Math.floor(robot.x), y: Math.floor(robot.y) }
      })
      $('#robots').text(JSON.stringify(robots))
    })

    socket.on('markers:update', function (markers) {
      window.markers = markers
      markers = markers.map((marker) => {
        return { x: Math.floor(marker.x), y: Math.floor(marker.y) }
      })
      $('#markers').text(JSON.stringify(markers))
    })

    socket.on('angles:update', function (angles) {
      window.angles = angles
      angles = angles.map((angle) => Math.floor(angle))
      $('#angles').text(JSON.stringify(angles))
    })

    socket.on('constraints:update', function (positions) {
      window.positions = positions
      $('#constraints').text(JSON.stringify(positions))
    })

    socket.on('pointer:update', function (pos) {
      window.pos = pos
      $('#pointer').text(JSON.stringify(pos))
    })

    socket.on('buffer', function (data) {
      window.rect = data.rect
      window.panel = data.panel

      show(data.buffer, 'canvas')
      show(data.bufferPanel, 'panel')
    })



    function selectMinDistance(startPos, otherPositions){
       //TODO

       return [nearest_pos, remainingPositions]
    }

    function sortedPositions(){
      const positions = window.robots.positions;
      let first_pos = positions.shift();
      let [second_pos, positions] = selectMinDistance(first_pos,positions);
      let [third_pos, fourth_pos] = selectMinDistance(second_pos,positions);
      return [first_pos,second_pos,third_pos,fourth_pos];
    }

    function drawRectFromCorners(context){
      conrtext.beginPath();
      let [first_pos,second_pos,third_pos,fourth_pos] = sortedPositions()
      context.moveTo(first_pos.x,first_pos.y);
      context.lineTo(second_pos.x,second_pos.y);
      context.lineTo(third_pos.x,third_pos.y);
      context.lineTo(fourth_pos.x,fourth_pos.y);
      context.lineTo(first_pos.x,first_pos.y);
      context.closePath();
      context.stroke();
      ctx.fillStyle="black";
      ctx.fill();
    }

    const show = (buffer, el) => {
      const canvas = document.getElementById(el)
      const context = canvas.getContext('2d')

      // drawRectFromCorners();

      const img = new Image()
      const uint8Arr = new Uint8Array(buffer);
      const str = String.fromCharCode.apply(null, uint8Arr);
      const base64String = btoa(str);
      img.onload = function () {
        context.drawImage(this, 0, 0, canvas.width, canvas.height)
      }
      img.src = 'data:image/png;base64,' + base64String
    }


  </script>


</body>
</html>
