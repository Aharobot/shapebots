<!doctype html>
<html>
  <head>
    <title>Shapebot</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { font: 13px Helvetica, Arial; }
      #table {float: left;}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.1/socket.io.js"></script>
    <script src="https://code.jquery.com/jquery-1.11.1.js"></script>
  </head>
  <body>

    <canvas id="table" width="520" height="390" ></canvas>

    <div>
     <p>Robot information</p> 
     <p><b>angle: </b><span id="robot_angle"></span></p>
     <p><b>Upper left position: </b></p>
     <p><b>    x: </b><span id="robot_x"></span></p>
     <p><b>    y: </b><span id="robot_y"></span></p>
     <p><b>Center of gravity: </b></p>
     <p><b>    cgx: </b><span id="robot_cgx"></span></p>
     <p><b>    cgy: </b><span id="robot_cgy"></span></p>
     <p><b>width: </b><span id="robot_width"></span></p>
     <p><b>height: </b><span id="robot_height"></span></p>
     <p><b>marker: </b></p>
     <p><b>    x: </b><span id="robot_marker_x"></span></p>
     <p><b>    y: </b><span id="robot_marker_y"></span></p>
     <p><b>Direction: </b><span id="direction"></span></p>
     <p><b>Pattern: </b><span id="robot_pattern"></span></p>
    </div>

    <hr/>
    <input id="distance" value="10" />
    <input id="angle" value="30" />
    <button id="send_arduino">send to Arduino</button>
    
    <script>
      $(function () {
        var socket = io();
        var robot = new Robot();
        var scale = 2;
        var x0 = 0;
        var y0 = 0;
        var camera_width = 1024;
        var camera_height= 768;
        var table_width = 1024/scale;
        var table_height = 768/scale;

        var table = document.getElementById("table");
        var ctx = table.getContext("2d");
        ctx.rect(x0,x0,table_width,table_height);
        ctx.stroke(); 

        function clearCanvas(){
          ctx.clearRect(x0,x0,table_width,table_height);
        }

        function Robot(){
          this.angle = 0;
          this.size = 0;
          this.points = [];

          this.angle_prev = 0;
          this.size_prev = 0;
          this.points_prev = [];

          this.x_ul = 0;
          this.y_ul = 0;
          this.x_ul_prev = 0
          this.y_ul_prev = 0;

          this.marker_x = 0;
          this.marker_y = 0;

          this.cgx = 0;
          this.cgy = 0;

          this.pattern = -1;
          this.true_pattern = -1;
        }

        function computeAngleOfCenterAndMarker(cgx,cgy,marker_x,marker_y,pattern){
          var angle;
          switch(pattern){
            case 1:
              if(robot.angle<-45){
                angle = Math.PI+Math.atan2(marker_y-cgy,cgx-marker_x);
              } else{ 
                angle = Math.PI-Math.atan2(cgy-marker_y,cgx-marker_x);
              }
            break;
            case 2:
              if(robot.angle<-45){
                angle = 2.5*Math.PI+Math.atan2(cgx-marker_x,cgy-marker_y);
              } else {
                angle = Math.PI+Math.atan2(marker_y-cgy,cgx-marker_x);
              }
            break;
              angle = Math.PI+Math.atan2(cgy-marker_y,marker_x-cgx);
            case 3:
              angle = 2*Math.PI-Math.atan2(marker_y-cgy,marker_x-cgx);
              break;
            case 4:
              angle = 2*Math.PI+Math.atan2(cgy-marker_y,marker_x-cgx);
              break;
          }
          return angle*180/Math.PI;
        }

        function detectPattern(marker_x,marker_y,cgx,cgy,angle){
          //1,2,3,4
          var pattern = -1;
          if(cgx-marker_x>0 && cgy-marker_y>0){
            pattern = 1;
          }else if(cgx-marker_x>0 && marker_y-cgy>0){
            pattern = 2;
          } else if(marker_x-cgx>0 && marker_y-cgy>0){
            pattern = 3;
          } else if(marker_x-cgx>0 && cgy-marker_y>0){
            pattern = 4;
          }

          robot.pattern = pattern;
          robot.true_pattern = pattern;

          if(angle<-45){
            if(pattern==1) {
              pattern=3;
            }
            if(pattern==2) {
              pattern=1;
            }
            else if(pattern==3) {
              pattern=2;
            }
            else if(pattern==4) {
              pattern=3;
            }

            robot.pattern = pattern;
          }
        }

        function drawMarker(){
          x = robot.marker_x/scale;
          y = robot.marker_y/scale;
          ctx.beginPath();
          ctx.fillStyle = 'red';
          ctx.arc(x,y,5,0,2*Math.PI);
        }

        function drawRobot(){
          angle = robot.angle;

          angle_prev = robot.angle_prev;
          height_prev = robot.size_prev.height/scale;
          width_prev = robot.size_prev.width/scale;
          height = robot.size.height/scale;
          width = robot.size.width/scale;
          x = robot.x_ul/scale;
          y = robot.y_ul/scale;
          x_prev = robot.x_ul_prev/scale;
          y_prev = robot.y_ul_prev/scale;
          // cgx = robot.cgx/scale;
          // cgy = robot.cgy/scale;

          clearCanvas();

          ctx.translate(x, y);
          ctx.rotate( angle * Math.PI / 180 );
          ctx.translate(-x, -y);

          ctx.fillStyle = 'black';
          ctx.fillRect(x,y,width,height);

          ctx.translate(x, y);
          ctx.rotate( -angle * Math.PI / 180 );
          ctx.translate(-x, -y);

          drawMarker();
          ctx.stroke(); 
          ctx.fill();

          direction = computeAngleOfCenterAndMarker(robot.cgx,robot.cgy,robot.marker_x,robot.marker_y,robot.pattern)-130;

          $("#direction").text(direction);
        }

        function computeCenterOfGravity(points){
          sumx = 0;
          sumy = 0;
          for(var i=0;i<points.length;i++){
            sumx += points[i].x;
            sumy += points[i].y;
          }
          cgx = sumx / points.length;
          cgy = sumy / points.length;

          robot.cgx = cgx;
          robot.cgy = cgy;
        }

        function showRobotInfo(){
          $("#robot_angle").text(robot.angle);
          $("#robot_x").text(robot.x_ul);
          $("#robot_y").text(robot.y_ul);
          $("#robot_cgx").text(robot.cgx);
          $("#robot_cgy").text(robot.cgy);
          $("#robot_width").text(robot.size.width);
          $("#robot_height").text(robot.size.height);
          $("#robot_marker_x").text(robot.marker_x);
          $("#robot_marker_y").text(robot.marker_y);
          $("#robot_pattern").text(robot.pattern);
        }

        function measureDistance(p1,p2){
          return Math.sqrt((p1.x-p2.x)**2+(p1.y-p2.y)**2)
        }

        function detectLeftUpper(pattern, points, marker_x,marker_y){
          var x_ul = 0;
          var y_ul = 0;
          if(pattern==1){
            min_d = 10e10;
            for(var i=0;i<points.length;i++){
              var distance =  Math.sqrt((points[i].x-marker_x)**2+(points[i].y-marker_y)**2);
              if (min_d > distance) {
                min_d = distance;
                x_ul = points[i].x;
                y_ul = points[i].y;
              }
            }

          } else if(pattern==2 || pattern==4){
            var distance_with_index = [];
            for(var i=0;i<points.length;i++){
              var distance =  Math.sqrt((points[i].x-marker_x)**2+(points[i].y-marker_y)**2);
              distance_with_index.push([distance,i]);
            }
            distance_with_index.sort(function(left, right) {
              return left[0] < right[0] ? -1 : 1;
            });
            var indices = [];
            var ds = [];
            for(var j in distance_with_index){
              ds.push(distance_with_index[j][0]);
              indices.push(distance_with_index[j][1]);
            }
            if(points[indices[1]].x < points[indices[2]].x){
              x_ul = points[indices[1]].x;
              y_ul = points[indices[1]].y;
            } else {
              x_ul = points[indices[2]].x;
              y_ul = points[indices[2]].y;
            }
          } else if(pattern==3){
            var distance_with_index = [];
            for(var i=0;i<points.length;i++){
              var distance =  Math.sqrt((points[i].x-marker_x)**2+(points[i].y-marker_y)**2);
              distance_with_index.push([distance,i]);
            }
            distance_with_index.sort(function(left, right) {
              return left[0] < right[0] ? -1 : 1;
            });
            var indices = [];
            var ds = [];
            for(var j in distance_with_index){
              ds.push(distance_with_index[j][0]);
              indices.push(distance_with_index[j][1]);
            }
            x_ul = points[indices[3]].x;
            y_ul = points[indices[3]].y;
          } 

            robot.x_ul = x_ul;
            robot.y_ul = y_ul;
        }


        socket.on('update_browser', function(msg){
          console.log(msg);
          robot.x_ul_prev = robot.x_ul;
          robot.y_ul_prev = robot.y_ul;
          robot.angle_prev = robot.angle;
          robot.size_prev = robot.size;
          robot.points_prev = robot.points;

          robot.angle = msg.angle;
          robot.size = msg.size;
          robot.points = msg.points;
          robot.marker_x = msg.marker_x;
          robot.marker_y = msg.marker_y;


          computeCenterOfGravity(robot.points);
          detectPattern(robot.marker_x,robot.marker_y,robot.cgx,robot.cgy,robot.angle);
          detectLeftUpper(robot.pattern, robot.points,robot.marker_x,robot.marker_y);

          console.log(robot);
          showRobotInfo();

          drawRobot();
          drawMarker();
        });

        $("#send_arduino").click(function(){
          var angle = $("#angle").val();
          var distance = $("#distance").val();
          socket.emit('update_position', {angle:angle, distance:distance});
        });

      });

    </script>
  </body>
</html>
