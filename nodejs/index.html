<!doctype html>
<html>
  <head>
    <title>Shapebot</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { font: 13px Helvetica, Arial; }
      #table {float: left;}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.1/socket.io.js"></script>
    <script src="https://code.jquery.com/jquery-1.11.1.js"></script>
  </head>
  <body>

    <canvas id="table" width="520" height="390" ></canvas>

    <div>
     <p>Robot information</p> 
     <p><b>angle: </b><span id="robot_angle"></span></p>
     <p><b>Upple left position: </b></p>
     <p><b>    x: </b><span id="robot_x"></span></p>
     <p><b>    y: </b><span id="robot_y"></span></p>
     <p><b>COG: </b></p>
     <p><b>    cgx: </b><span id="robot_cgx"></span></p>
     <p><b>    cgy: </b><span id="robot_cgy"></span></p>
     <p><b>width: </b><span id="robot_width"></span></p>
     <p><b>height: </b><span id="robot_height"></span></p>
     <p><b>marker: </b></p>
     <p><b>    x: </b><span id="robot_marker_x"></span></p>
     <p><b>    y: </b><span id="robot_marker_y"></span></p>
    </div>

<!--     <p>angle [degree]</p>
    <input id="angle"/>
    <p>destination [cm]</p>
    <input id="destination" />
    <button id="update_position">update position</button>
 -->
    <script>
      $(function () {
        var socket = io();
        var robot = new Robot();
        var scale = 2;
        var x0 = 0;
        var y0 = 0;
        var camera_width = 1024;
        var camera_height= 768;
        var table_width = 1024/scale;
        var table_height = 768/scale;

        var table = document.getElementById("table");
        var ctx = table.getContext("2d");
        ctx.rect(x0,x0,table_width,table_height);
        ctx.stroke(); 

        function clearCanvas(){
          ctx.clearRect(x0,x0,table_width,table_height);
        }

        function Robot(){
          this.angle = 0;
          this.size = 0;
          this.points = [];

          this.angle_prev = 0;
          this.size_prev = 0;
          this.points_prev = [];

          this.x_ul = 0;
          this.y_ul = 0;
          this.x_ul_prev = 0
          this.y_ul_prev = 0;

          // this.upper_left_index = -1;
          // this.lower_left_index = -1;
          // this.upper_right_index = -1;
          // this.lower_right_index = -1;

          this.marker_x = 0;
          this.marker_y = 0;

          this.cgx = 0;
          this.cgy = 0;

          this.pattern = -1;
        }

        function detectPattern(marker_x,marker_y,cgx,cgy,angle){
          //1,2,3,4
          var pattern = -1;
          if(cgx-marker_x>0 && cgy-marker_y>0){
            pattern = 1;
          }else if(cgx-marker_x>0 && marker_y-cgy>0){
            pattern = 2;
          } else if(marker_x-cgx>0 && marker_y-cgy>0){
            pattern = 3;
          } else if(marker_x-cgx>0 && cgy-marker_y>0){
            pattern = 4;
          }
          if(angle<-45){
            if(pattern==1) {
              pattern=3;
            }
            if(pattern==2) {
              pattern=1;
            }
            else if(pattern==3) {
              pattern=2;
            }
            else if(pattern==4) {
              pattern=3;
            }
          }
          return pattern;
        }

        function drawMarker(){
          x = robot.marker_x/scale;
          y = robot.marker_y/scale;
          ctx.beginPath();
          ctx.fillStyle = 'red';
          ctx.arc(x,y,5,0,2*Math.PI);
        }

        function drawRobot(){
          angle = robot.angle;

          angle_prev = robot.angle_prev;
          height_prev = robot.size_prev.height/scale;
          width_prev = robot.size_prev.width/scale;
          height = robot.size.height/scale;
          width = robot.size.width/scale;
          x = robot.x_ul/scale;
          y = robot.y_ul/scale;
          x_prev = robot.x_ul_prev/scale;
          y_prev = robot.y_ul_prev/scale;
          // cgx = robot.cgx/scale;
          // cgy = robot.cgy/scale;

          clearCanvas();

          // if(angle<-45){
          //   ctx.translate(x, y);
          //   ctx.rotate( (angle-180) * Math.PI / 180 );
          //   ctx.translate(-x, -y);
          // }else {
            ctx.translate(x, y);
            ctx.rotate( angle * Math.PI / 180 );
            ctx.translate(-x, -y);
          // }

          // if(angle<-45){
          //   ctx.translate(x, y);
          //   ctx.rotate( -180 * Math.PI / 180 );
          //   offset_x = width*Math.sin((90+angle)*Math.PI/180);
          //   offset_y = width*Math.cos((90+angle)*Math.PI/180);
          //   console.log("offset");
          //   console.log(offset_x,offset_y);
          // }

          ctx.fillStyle = 'black';
          ctx.fillRect(x,y,width,height);

          // if(angle<-45){
          //   ctx.translate(-offset_x, -offset_y);
          //   ctx.rotate( 180 * Math.PI / 180 );
          //   ctx.translate(-x, -y);
          // }

          // if(angle<-45){
            // offset_x = width*Math.sin((90+angle)*Math.PI/180);
            // offset_y = width*Math.cos((90+angle)*Math.PI/180);
          //   ctx.translate(x, y);
          //   ctx.rotate( -(angle-180) * Math.PI / 180 );
          //   ctx.translate(-x, -y);
          // }else {
            ctx.translate(x, y);
            ctx.rotate( -angle * Math.PI / 180 );
            ctx.translate(-x, -y);
          // }


          drawMarker();
          ctx.stroke(); 
          ctx.fill();
        }

        // function computeOffset(x,y,cgx,cgy,angle){
        //   cgx1 = cgx-x;
        //   cgy1 = cgy-y;
        //   r = Math.sqrt(cgx1*cgx1+cgy1*cgy1);
        //   cgx2 = r*cos(angle*Math.PI/180);
        //   cgy2 = r*sin(angle*Math.PI/180);
        //   offset_x = cgx2 - cgx1;
        //   offset_y = cgy2 - cgy1;
        //   offset = {x:offset_x, y:offset_y};
        //   return offset;
        // }

        // function updateLeftUpperPoint(points){
        //   robot.x_ul = points[robot.upper_left_index].x;
        //   robot.y_ul = points[robot.upper_left_index].y;
        // }

        function computeCenterOfGravity(points){
          sumx = 0;
          sumy = 0;
          for(var i=0;i<points.length;i++){
            sumx += points[i].x;
            sumy += points[i].y;
          }
          cgx = sumx / points.length;
          cgy = sumy / points.length;

          robot.cgx = cgx;
          robot.cgy = cgy;
        }

        function showRobotInfo(){
          $("#robot_angle").text(robot.angle);
          $("#robot_x").text(robot.x_ul);
          $("#robot_y").text(robot.y_ul);
          $("#robot_cgx").text(robot.cgx);
          $("#robot_cgy").text(robot.cgy);
          $("#robot_width").text(robot.size.width);
          $("#robot_height").text(robot.size.height);
          $("#robot_marker_x").text(robot.marker_x);
          $("#robot_marker_y").text(robot.marker_y);
        }

        function measureDistance(p1,p2){
          return Math.sqrt((p1.x-p2.x)**2+(p1.y-p2.y)**2)
        }

        function detectLeftUpper(pattern, points, marker_x,marker_y){
          var x_ul = 0;
          var y_ul = 0;
          if(pattern==1){
            min_d = 10e10;
            for(var i=0;i<points.length;i++){
              var distance =  Math.sqrt((points[i].x-marker_x)**2+(points[i].y-marker_y)**2);
              if (min_d > distance) {
                min_d = distance;
                x_ul = points[i].x;
                y_ul = points[i].y;
              }
            }

          } else if(pattern==2 || pattern==4){
            var distance_with_index = [];
            for(var i=0;i<points.length;i++){
              var distance =  Math.sqrt((points[i].x-marker_x)**2+(points[i].y-marker_y)**2);
              distance_with_index.push([distance,i]);
            }
            distance_with_index.sort(function(left, right) {
              return left[0] < right[0] ? -1 : 1;
            });
            var indices = [];
            var ds = [];
            for(var j in distance_with_index){
              ds.push(distance_with_index[j][0]);
              indices.push(distance_with_index[j][1]);
            }
            if(points[indices[1]].x < points[indices[2]].x){
              x_ul = points[indices[1]].x;
              y_ul = points[indices[1]].y;
            } else {
              x_ul = points[indices[2]].x;
              y_ul = points[indices[2]].y;
            }
          } else if(pattern==3){
            var distance_with_index = [];
            for(var i=0;i<points.length;i++){
              var distance =  Math.sqrt((points[i].x-marker_x)**2+(points[i].y-marker_y)**2);
              distance_with_index.push([distance,i]);
            }
            distance_with_index.sort(function(left, right) {
              return left[0] < right[0] ? -1 : 1;
            });
            var indices = [];
            var ds = [];
            for(var j in distance_with_index){
              ds.push(distance_with_index[j][0]);
              indices.push(distance_with_index[j][1]);
            }
            x_ul = points[indices[3]].x;
            y_ul = points[indices[3]].y;
          } 

            robot.x_ul = x_ul;
            robot.y_ul = y_ul;
        }


        // function sortPointIndices(points,angle){
        //   //1:Upper left, 2:Lower left, 3:Upper right, 4:Lower right
        //   var upper_left_index;
        //   var lower_left_index;
        //   var upper_right_index;
        //   var lower_right_index;

        //     var x_with_index = [];
        //     for (var i=0; i<points.length;i++) {
        //       x_with_index.push([points[i].x, i]);
        //     }

        //     x_with_index.sort(function(left, right) {
        //       return left[0] < right[0] ? -1 : 1;
        //     });
        //     var indices = [];
        //     xs = [];

        //     for (var j in x_with_index) {
        //       xs.push(x_with_index[j][0]);
        //       indices.push(x_with_index[j][1]);
        //     }

        //     left_indices = indices.slice(0,2);
        //     right_indices = indices.slice(2,4);

        //     if(points[left_indices[0]].y < points[left_indices[1]].y ){
        //       upper_left_index = left_indices[0];
        //       lower_left_index = left_indices[1];
        //     } else {
        //       upper_left_index = left_indices[1];
        //       lower_left_index = left_indices[0];
        //     }

        //     if(points[right_indices[0]].y < points[right_indices[1]].y ){
        //       upper_right_index = right_indices[0];
        //       lower_right_index = right_indices[1];
        //     } else {
        //       upper_right_index = right_indices[1];
        //       lower_right_index = right_indices[0];
        //     }

        //   robot.upper_left_index = upper_left_index;
        //   robot.lower_left_index = lower_left_index;
        //   robot.upper_right_index = upper_right_index;
        //   robot.lower_right_index = lower_right_index;
        // }

        socket.on('update_browser', function(msg){
          console.log(msg);
          robot.x_ul_prev = robot.x_ul;
          robot.y_ul_prev = robot.y_ul;
          robot.angle_prev = robot.angle;
          robot.size_prev = robot.size;
          robot.points_prev = robot.points;

          robot.angle = msg.angle;
          robot.size = msg.size;
          robot.points = msg.points;
          robot.marker_x = msg.marker_x;
          robot.marker_y = msg.marker_y;

          // sortPointIndices(msg.points);
          // updateLeftUpperPoint(robot.points);

          computeCenterOfGravity(robot.points);
          robot.pattern = detectPattern(robot.marker_x,robot.marker_y,robot.cgx,robot.cgy,robot.angle);
          detectLeftUpper(robot.pattern, robot.points,robot.marker_x,robot.marker_y);

          console.log(robot);
          showRobotInfo();

          drawRobot();
          drawMarker();
        });

        // $("#update_position").click(function(){
        //   var angle = $("#angle").text();
        //   var destination  = $("#destination").text();
        //   socket.emit('update_position', {angle:angle, destination:destination});
        // });
      });

    </script>
  </body>
</html>
